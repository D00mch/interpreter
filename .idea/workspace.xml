<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="805c7f0f-3ea2-4af6-b1e7-e3f023cc2b8a" name="Default Changelist" comment="ad">
      <change beforePath="$PROJECT_DIR$/.idea/dictionaries/dumchev.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/dictionaries/dumchev.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_clojure_tools_nrepl_0_2_12.xml" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/interpreter.iml" beforeDir="false" afterPath="$PROJECT_DIR$/interpreter.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/interpreter/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/interpreter/core.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/interpreter/driver.clj" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/src/interpreter/impl/default.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/interpreter/impl/default.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/interpreter/impl/nondeterministic.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/interpreter/impl/nondeterministic.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/test/interpreter/default_test.clj" beforeDir="false" afterPath="$PROJECT_DIR$/test/interpreter/default_test.clj" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/interpreter/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="135">
              <caret line="9" column="10" selection-start-line="9" selection-start-column="10" selection-end-line="9" selection-end-column="10" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/interpreter/impl/default.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="150">
              <caret line="10" column="9" selection-start-line="10" selection-start-column="9" selection-end-line="10" selection-end-column="9" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="291">
              <caret line="189" column="1" selection-start-line="189" selection-start-column="1" selection-end-line="189" selection-end-column="1" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Kotlin File" />
        <option value="Clojure Test Namespace" />
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>i-eval</find>
      <find>i-apply</find>
      <find>eval</find>
      <find>(defn- apply</find>
      <find>Proc.</find>
    </findStrings>
    <replaceStrings>
      <replace>eval</replace>
      <replace>apply</replace>
      <replace>i-eval</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/src/interpreter/raw.kt" />
        <option value="$PROJECT_DIR$/src/interpreter/raw.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/raw2.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/eval.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/impl/basic.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/printer.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/impl/type.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/driver.clj" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/type.clj" />
        <option value="$PROJECT_DIR$/test/interpreter/default_test.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/impl/nondeterministic.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/core.clj" />
        <option value="$PROJECT_DIR$/src/interpreter/impl/default.clj" />
      </list>
    </option>
  </component>
  <component name="MavenProjectNavigator">
    <treeState>
      <expand />
      <select />
    </treeState>
  </component>
  <component name="ProjectFrameBounds">
    <option name="y" value="23" />
    <option name="width" value="1440" />
    <option name="height" value="877" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <autoscrollFromSource ProjectPane="true" />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="impl" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="interpreter" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="External Libraries" type="cb654da1:ExternalLibrariesNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="External Libraries" type="cb654da1:ExternalLibrariesNode" />
              <item name="Leiningen: org.clojure/clojure:1.9.0" type="70bed36:NamedLibraryElementNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="External Libraries" type="cb654da1:ExternalLibrariesNode" />
              <item name="Leiningen: org.clojure/clojure:1.9.0" type="70bed36:NamedLibraryElementNode" />
              <item name="clojure-1.9.0.jar" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="interpreter" type="b2602c69:ProjectViewProjectNode" />
              <item name="External Libraries" type="cb654da1:ExternalLibrariesNode" />
              <item name="Leiningen: org.clojure/clojure:1.9.0" type="70bed36:NamedLibraryElementNode" />
              <item name="clojure-1.9.0.jar" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1551290479935" />
    <property name="cursive.last.file.extension./Users/dumchev/IdeaProjects/clj/interpreter/src" value="clj" />
    <property name="cursive.last.file.extension./Users/dumchev/IdeaProjects/clj/interpreter/test" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="preferences.sourceCode.Clojure" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/src/interpreter/impl" />
    </key>
  </component>
  <component name="ReplState" timestamp="1551290643805">{:repl-history {:ide [], :local [{:command &quot;(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3202, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(def r (eval-sexp '(+ 1 1) {}))&quot;, :offset 31, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(declare analyze)\n\n(defn- execute-application\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; + proc)\n      (succeed (clj-apply proc args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 595, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmulti analyze-seq (fn [exp] (first exp)))\n\n(defn- amb-choices [exp] (rest exp))\n\n(defn amb-try-next [choices env succeed fail]\n  (if (empty? choices)\n    (fail)\n    ((first choices)\n      env\n      succeed\n      (fn [] (amb-try-next (rest choices) env succeed fail)))))\n\n(defmethod analyze-seq 'amb\n  [exp]\n  (let [cprocs (map analyze (amb-choices exp))]\n    (println cprocs)\n    (fn [env succeed fail]\n      (amb-try-next cprocs env succeed fail))))\n\n(defn- sequentially [a b stop? init]\n  (fn [env succeed fail]\n    (a env\n       (fn [a-value fail2]\n         (if (stop? a-value)\n           (b env succeed fail2)\n           (succeed (State. (not init) env)\n                    fail2)))\n       fail)))\n(defn- analyze-logic [exps stop? init]\n  (loop [first-proc (fn [env succeed fail] (succeed (State. init env) fail))\n         rest-procs (map analyze exps)]\n    (if (empty? rest-procs)\n      first-proc\n      (recur (sequentially first-proc (first rest-procs) stop? init)\n             (rest rest-procs)))))\n(defmethod analyze-seq 'and\n  [[_ exps]]\n  (analyze-logic exps identity true))\n(defmethod analyze-seq 'or\n  [[_ exps]]\n  (analyze-logic exps not false))\n\n(defn- get-args [aprocs env succeed fail]\n  (if (empty? aprocs)\n    (succeed (State. '() env) fail)\n    ((first aprocs)\n      env\n      ;; succeed for this aproc\n      (fn [arg fail2]\n        (get-args (rest aprocs)\n                  env\n                  ;; succeed for get-args\n                  (fn [args fail3]\n                    (succeed (State. (cons arg args) env)\n                             fail3))\n                  fail2))\n      fail)))\n(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             (fn [proc fail2]\n               (get-args aprocs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap\&quot;)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 2162, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq 'def\n  [[_ name val]]\n  (let [vproc (analyze val)]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'defn\n  [[_ name params &amp; body]]\n  (let [vproc (analyze (make-fn params body))]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'fn\n  [_ vars body]                                             ; body\n  (let [bproc (analyze-seq body)]\n    (fn [env succeed fail]\n      (succeed\n        (State.\n          (Proc. vars bproc env nil)\n          env)\n        fail))))\n\n(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))\n\n(defn ambeval\n  \&quot;succeed is like  (fn [val fail] ...)\n   fail    is like  (fn [] ... )\&quot;\n  [exp env succeed fail]\n  ((analyze exp) env succeed fail))\n\n\n(def ^:private input-prompt \&quot;;;; Input Amb-Eval:\&quot;)\n(def ^:private output-prompt \&quot;;;; Values Amb-Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- announce-output [str]\n  (println str))\n(defn- user-print [object]\n  (println output-prompt object))\n\n(def global-state-atom (atom initial-state))\n\n(declare driver-loop)\n(defn- driver-loop-inner [try-again]\n  (prompt-for-input input-prompt)\n  (let [input (read-string (read-line))]\n    (if (= input 'try-again)\n      (try-again)\n      (do\n        (println \&quot;;;; starting a new problem\&quot;)\n        (ambeval input                                      ; do we need to wrap it in list?\n                 (:env #'global-state-atom)\n                 ;; success continuation\n                 (fn [output-state next-alternative]\n                   (announce-output output-prompt)\n                   (user-print (:result output-state))\n                   (swap! global-state-atom (fn [_] output-state))\n                   (driver-loop-inner next-alternative))\n                 ;; failure continuation\n                 (fn []\n                   (announce-output \&quot;;;; there are no more values of \&quot;)\n                   (user-print input)\n                   (driver-loop)))))))\n(defn driver-loop []\n  (driver-loop-inner\n    (fn []\n      (println \&quot;;;; no current problem\&quot;)\n      (driver-loop))))&quot;, :offset 2612, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 574, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(apply '+ '(1 1))&quot;, :offset 17, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(ns-name *ns*)&quot;, :offset 14, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (clj-apply proc args))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 544, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (do\n    (println \&quot;it's a primitive proc \&quot; proc)\n    (clj-apply proc args)))&quot;, :offset 172, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(primitive-procedure? '+)&quot;, :offset 25, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(primitive-procedure? +)&quot;, :offset 24, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure-name? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply (primitive-procedure-map proc) args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 618, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(execute-application + '(1 1) #(println %) #(println 'fail))&quot;, :offset 60, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(execute-application '+ '(1 1) #(println %) #(println 'fail))&quot;, :offset 61, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(execute-application '+ '(1 1) #(println %1) #(println 'fail))&quot;, :offset 62, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure-name? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply (primitive-procedure-map proc) \n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 645, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(execute-application '+ '(1 1) #(println %1 %2) #(println 'fail))&quot;, :offset 65, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             (fn [proc fail2]\n               (get-args aprocs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 559, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (println \&quot;fproc is \&quot; fproc)\n    (println \&quot;aprocs are \&quot; aprocs)\n    (fn [env succeed fail]\n      (fproc env\n             (fn [proc fail2]\n               (get-args aprocs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 626, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))&quot;, :offset 304, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))&quot;, :offset 1871, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 1371, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))&quot;, :offset 212, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))&quot;, :offset 200, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(eval-sexp '(+ 1 1) {})\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3471, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(eval-sexp '(+ 1 1) {})\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n;(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3472, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (State. (apply (eval op env)\n                 (map (fn [operand]\n                        (eval operand env))\n                      operands))\n          env))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n;(eval-sexp '(+ 1 1))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n;(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3470, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (println \&quot;evOp is \&quot; evaled-op)\n    (State. (apply evaled-op\n                   (map (fn [operand]\n                          (eval operand env))\n                        operands))\n            env)))\n\n\n;(eval-sexp '(+ 1 1) {})\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n;(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3549, :ns &quot;user&quot;} {:command &quot;(eval-sexp '(+ 1 1) {})&quot;, :offset 23, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (println \&quot;evOp is \&quot; evaled-op)\n    (State. (apply evaled-op\n                   (map (fn [operand]\n                          (eval operand env))\n                        operands))\n            env)))&quot;, :offset 287, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(require '[clojure.data.codec.base64 :as b64]\n         '[clojure.java.io :as io])&quot;, :offset 81, :ns &quot;interpreter.core&quot;} {:command &quot;(ns interpreter.core\n  (:require [interpreter.impl.default :as default]\n            [clojure.data.codec.base64 :as b64]\n            [clojure.java.io :as io]\n            )\n  (:gen-class))&quot;, :offset 186, :ns &quot;user&quot;} {:command &quot;(ns interpreter.core\n  (:require [interpreter.impl.default :as default])\n  (:gen-class)\n  (:import (java.util Base64)))&quot;, :offset 119, :ns &quot;user&quot;} {:command &quot;(defn encode [to-encode]\n  (.encode (Base64/getEncoder) (.getBytes to-encode)))&quot;, :offset 79, :ns &quot;interpreter.core&quot;} {:command &quot;(encode (.getBytes \&quot;Hello world!\&quot;))&quot;, :offset 35, :ns &quot;interpreter.core&quot;} {:command &quot;(defn encode [to-encode]\n  (.encodeToString (Base64/getEncoder) (.getBytes to-encode)))&quot;, :offset 87, :ns &quot;interpreter.core&quot;} {:command &quot;(encode \&quot;Hello world!\&quot;)&quot;, :offset 23, :ns &quot;interpreter.core&quot;} {:command &quot;(decode \&quot;SGVsbG8gd29ybGQh\&quot;)&quot;, :offset 27, :ns &quot;interpreter.core&quot;} {:command &quot;(encode \&quot;93:51:1e:b2:f0:7c:d4:4c:18:74:f1:68:be:29:4b:67:db:92:4a:d3\&quot;)&quot;, :offset 70, :ns &quot;interpreter.core&quot;} {:command &quot;(defn decode [to-decode]\n  (String. (.decode (Base64/getDecoder) to-decode)))&quot;, :offset 77, :ns &quot;interpreter.core&quot;} {:command &quot;(encode \&quot;15:DE:1F:82:F5:B5:CA:1B:3D:8B:C7:A2:AE:0B:B3:6E:40:B3:2C:2B\&quot;)&quot;, :offset 70, :ns &quot;interpreter.core&quot;} {:command &quot;(decode \&quot;2jmj7l5rSw0yVb/vlWAYkK/YBwk=\&quot;)&quot;, :offset 39, :ns &quot;interpreter.core&quot;} {:command &quot;(encode \&quot;2jmj7l5rSw0yVb/vlWAYkK/YBwk=\&quot;)&quot;, :offset 39, :ns &quot;interpreter.core&quot;} {:command &quot;(defmethod analyze-seq 'def\n  [[_ name val]]\n  (let [vproc (analyze val)]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'defn\n  [[_ name params &amp; body]]\n  (let [vproc (analyze (make-fn params body))]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'fn\n  [_ vars body]                                             ; body\n  (let [bproc (analyze-seq body)]\n    (fn [env succeed fail]\n      (succeed\n        (State.\n          (Proc. vars bproc env nil)\n          env)\n        fail))))\n\n(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    (primitive-procedure-name? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (primitive-procedure-map exp) env)\n        fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))\n\n(defn ambeval\n  \&quot;succeed is like  (fn [val fail] ...)\n   fail    is like  (fn [] ... )\&quot;\n  [exp env succeed fail]\n  ((analyze exp) env succeed fail))\n\n\n(def ^:private input-prompt \&quot;;;; Input Amb-Eval:\&quot;)\n(def ^:private output-prompt \&quot;;;; Values Amb-Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- announce-output [str]\n  (println str))\n(defn- user-print [object]\n  (println output-prompt object))\n\n(def global-state-atom (atom initial-state))\n\n(declare driver-loop)\n(defn- driver-loop-inner [try-again]\n  (prompt-for-input input-prompt)\n  (let [input (read-string (read-line))]\n    (if (= input 'try-again)\n      (try-again)\n      (do\n        (println \&quot;;;; starting a new problem\&quot;)\n        (ambeval input                                      ; do we need to wrap it in list?\n                 (:env #'global-state-atom)\n                 ;; success continuation\n                 (fn [output-state next-alternative]\n                   (announce-output output-prompt)\n                   (user-print (:result output-state))\n                   (swap! global-state-atom (fn [_] output-state))\n                   (driver-loop-inner next-alternative))\n                 ;; failure continuation\n                 (fn []\n                   (announce-output \&quot;;;; there are no more values of \&quot;)\n                   (user-print input)\n                   (driver-loop)))))))\n(defn driver-loop []\n  (driver-loop-inner\n    (fn []\n      (println \&quot;;;; no current problem\&quot;)\n      (driver-loop))))&quot;, :offset 2757, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             ;; succeed\n             (fn [proc fail2]\n               (get-args (:result aprocs)\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 593, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    ;(primitive-procedure-name? exp)\n    ;(fn [env succeed fail]\n    ;  (succeed\n    ;    (State. (primitive-procedure-map exp) env)\n    ;    fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))&quot;, :offset 468, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             ;; succeed\n             (fn [proc fail2]\n               (get-args aprocs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 583, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(#{1 2 3} 3)&quot;, :offset 12, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(#{1 2 3} 4)&quot;, :offset 12, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(1 #{1 2 3})&quot;, :offset 12, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn primitive-procedure? [proc]\n  ((set (vals primitive-procedure-map)) (:result proc)))&quot;, :offset 90, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- primitive? [proc]\n  ((set (vals primitive-procedure-map)) (:result proc)))&quot;, :offset 81, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc\n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 603, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(def a (analyze '(+ 1 1)))&quot;, :offset 26, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc\n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))&quot;, :offset 613, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(ns interpreter.impl.nondeterministic\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))&quot;, :offset 209, :ns &quot;user&quot;} {:command &quot;(declare analyze)\n\n(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc\n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))\n\n;(execute-application '+ '(1 1) #(println %1 %2) #(println 'fail))\n\n(defmulti analyze-seq (fn [exp] (first exp)))\n\n(defn- amb-choices [exp] (rest exp))\n\n(defn amb-try-next [choices env succeed fail]\n  (if (empty? choices)\n    (fail)\n    ((first choices)\n      env\n      succeed\n      (fn [] (amb-try-next (rest choices) env succeed fail)))))\n\n(defmethod analyze-seq 'amb\n  [exp]\n  (let [cprocs (map analyze (amb-choices exp))]\n    (println cprocs)\n    (fn [env succeed fail]\n      (amb-try-next cprocs env succeed fail))))\n\n(defn- sequentially [a b stop? init]\n  (fn [env succeed fail]\n    (a env\n       (fn [a-value fail2]\n         (if (stop? a-value)\n           (b env succeed fail2)\n           (succeed (State. (not init) env)\n                    fail2)))\n       fail)))\n(defn- analyze-logic [exps stop? init]\n  (loop [first-proc (fn [env succeed fail] (succeed (State. init env) fail))\n         rest-procs (map analyze exps)]\n    (if (empty? rest-procs)\n      first-proc\n      (recur (sequentially first-proc (first rest-procs) stop? init)\n             (rest rest-procs)))))\n(defmethod analyze-seq 'and\n  [[_ exps]]\n  (analyze-logic exps identity true))\n(defmethod analyze-seq 'or\n  [[_ exps]]\n  (analyze-logic exps not false))\n\n(defn- get-args [aprocs env succeed fail]\n  (if (empty? aprocs)\n    (succeed (State. '() env) fail)\n    ((first aprocs)\n      env\n      ;; succeed for this aproc\n      (fn [arg fail2]\n        (get-args (rest aprocs)\n                  env\n                  ;; succeed for get-args\n                  (fn [args fail3]\n                    (succeed (State. (cons arg args) env)\n                             fail3))\n                  fail2))\n      fail)))\n(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        aprocs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             ;; succeed\n             (fn [proc fail2]\n               (get-args aprocs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))&quot;, :offset 2900, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defmethod analyze-seq 'def\n  [[_ name val]]\n  (let [vproc (analyze val)]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'defn\n  [[_ name params &amp; body]]\n  (let [vproc (analyze (make-fn params body))]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'fn\n  [_ vars body]                                             ; body\n  (let [bproc (analyze-seq body)]\n    (fn [env succeed fail]\n      (succeed\n        (State.\n          (Proc. vars bproc env nil)\n          env)\n        fail))))\n\n(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    ;(primitive-procedure-name? exp)\n    ;(fn [env succeed fail]\n    ;  (succeed\n    ;    (State. (primitive-procedure-map exp) env)\n    ;    fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))\n\n(defn ambeval\n  \&quot;succeed is like  (fn [val fail] ...)\n   fail    is like  (fn [] ... )\&quot;\n  [exp env succeed fail]\n  ((analyze exp) env succeed fail))\n\n\n(def ^:private input-prompt \&quot;;;; Input Amb-Eval:\&quot;)\n(def ^:private output-prompt \&quot;;;; Values Amb-Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- announce-output [str]\n  (println str))\n(defn- user-print [object]\n  (println output-prompt object))\n\n(def global-state-atom (atom initial-state))\n\n(declare driver-loop)\n(defn- driver-loop-inner [try-again]\n  (prompt-for-input input-prompt)\n  (let [input (read-string (read-line))]\n    (if (= input 'try-again)\n      (try-again)\n      (do\n        (println \&quot;;;; starting a new problem\&quot;)\n        (ambeval input                                      ; do we need to wrap it in list?\n                 (:env #'global-state-atom)\n                 ;; success continuation\n                 (fn [output-state next-alternative]\n                   (announce-output output-prompt)\n                   (user-print (:result output-state))\n                   (swap! global-state-atom (fn [_] output-state))\n                   (driver-loop-inner next-alternative))\n                 ;; failure continuation\n                 (fn []\n                   (announce-output \&quot;;;; there are no more values of \&quot;)\n                   (user-print input)\n                   (driver-loop)))))))\n(defn driver-loop []\n  (driver-loop-inner\n    (fn []\n      (println \&quot;;;; no current problem\&quot;)\n      (driver-loop))))&quot;, :offset 2762, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare apply eval)\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'NIL\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (println \&quot;evOp is \&quot; evaled-op)\n    (State. (apply evaled-op\n                   (map (fn [operand]\n                          (eval operand env))\n                        operands))\n            env)))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name exp] operands\n                value (eval exp env)]\n            (assoc env name value))))\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (State. 'NIL\n          (let [[name params body] operands\n                new-fn (Proc. params body env name)]\n            (assoc env name new-fn))))\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (State. (eval-if sexp env) env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (State. (Proc. params\n                   body\n                   env\n                   nil)\n            env)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    (State. sexp env)\n\n    (primitive-procedure-name? sexp)\n    (State. (primitive-procedure-map sexp) env)\n\n    (symbol? sexp)\n    (State. (env sexp) env)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n\n;(apply + '(1 1))\n\n\n(defn- eval\n  ([sexp] (eval sexp {}))\n  ([sexp env]\n   (:result (eval-sexp sexp env))))\n\n(defn- next-state [last-state sexp]\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n\n(def ^:private input-prompt \&quot;write your code below\&quot;)\n(def ^:private output-prompt \&quot;&gt;&gt; \&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- user-print [object]\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))&quot;, :offset 3522, :ns &quot;user&quot;} {:command &quot;(apply + '(1 1))&quot;, :offset 16, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(ns interpreter.impl.nondeterministic\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)))\n\n(declare analyze)\n\n(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc\n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))\n\n;(execute-application '+ '(1 1) #(println %1 %2) #(println 'fail))\n\n(defmulti analyze-seq (fn [exp] (first exp)))\n\n(defn- amb-choices [exp] (rest exp))\n\n(defn amb-try-next [choices env succeed fail]\n  (if (empty? choices)\n    (fail)\n    ((first choices)\n      env\n      succeed\n      (fn [] (amb-try-next (rest choices) env succeed fail)))))\n\n(defmethod analyze-seq 'amb\n  [exp]\n  (let [cprocs (map analyze (amb-choices exp))]\n    (println cprocs)\n    (fn [env succeed fail]\n      (amb-try-next cprocs env succeed fail))))\n\n(defn- sequentially [a b stop? init]\n  (fn [env succeed fail]\n    (a env\n       (fn [a-value fail2]\n         (if (stop? a-value)\n           (b env succeed fail2)\n           (succeed (State. (not init) env)\n                    fail2)))\n       fail)))\n(defn- analyze-logic [exps stop? init]\n  (loop [first-proc (fn [env succeed fail] (succeed (State. init env) fail))\n         rest-procs (map analyze exps)]\n    (if (empty? rest-procs)\n      first-proc\n      (recur (sequentially first-proc (first rest-procs) stop? init)\n             (rest rest-procs)))))\n(defmethod analyze-seq 'and\n  [[_ exps]]\n  (analyze-logic exps identity true))\n(defmethod analyze-seq 'or\n  [[_ exps]]\n  (analyze-logic exps not false))\n\n(defn- get-args [aprocs env succeed fail]\n  (if (empty? aprocs)\n    (succeed (State. '() env) fail)\n    ((first aprocs)\n      env\n      ;; succeed for this aproc\n      (fn [arg fail2]\n        (get-args (rest aprocs)\n                  env\n                  ;; succeed for get-args\n                  (fn [args fail3]\n                    (succeed (State. (cons arg args) env)\n                             fail3))\n                  fail2))\n      fail)))\n(defmethod analyze-seq :default\n  ;; apply\n  [[op &amp; operands]]\n  (println \&quot;default\&quot;)\n  (let [fproc  (analyze op)\n        arg-procs (map analyze operands)]\n    (fn [env succeed fail]\n      (fproc env\n             ;; succeed\n             (fn [proc fail2]\n               (get-args arg-procs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))\n\n;; todo: remove\n;(def a (analyze '(+ 1 1)))\n;\n;(a {}\n;   (fn [a b] (println a))\n;   (fn [] (println 'e)))\n\n(defmethod analyze-seq 'def\n  [[_ name val]]\n  (let [vproc (analyze val)]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'defn\n  [[_ name params &amp; body]]\n  (let [vproc (analyze (make-fn params body))]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'fn\n  [_ vars body]                                             ; body\n  (let [bproc (analyze-seq body)]\n    (fn [env succeed fail]\n      (succeed\n        (State.\n          (Proc. vars bproc env nil)\n          env)\n        fail))))\n\n(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    ;(primitive-procedure-name? exp)\n    ;(fn [env succeed fail]\n    ;  (succeed\n    ;    (State. (primitive-procedure-map exp) env)\n    ;    fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))\n\n(defn ambeval\n  \&quot;succeed is like  (fn [val fail] ...)\n   fail    is like  (fn [] ... )\&quot;\n  [exp env succeed fail]\n  ((analyze exp) env succeed fail))\n\n\n(def ^:private input-prompt \&quot;;;; Input Amb-Eval:\&quot;)\n(def ^:private output-prompt \&quot;;;; Values Amb-Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- announce-output [str]\n  (println str))\n(defn- user-print [object]\n  (println output-prompt object))\n\n(def global-state-atom (atom initial-state))\n\n(declare driver-loop)\n(defn- driver-loop-inner [try-again]\n  (prompt-for-input input-prompt)\n  (let [input (read-string (read-line))]\n    (if (= input 'try-again)\n      (try-again)\n      (do\n        (println \&quot;;;; starting a new problem\&quot;)\n        (ambeval input                                      ; do we need to wrap it in list?\n                 (:env #'global-state-atom)\n                 ;; success continuation\n                 (fn [output-state next-alternative]\n                   (announce-output output-prompt)\n                   (user-print (:result output-state))\n                   (swap! global-state-atom (fn [_] output-state))\n                   (driver-loop-inner next-alternative))\n                 ;; failure continuation\n                 (fn []\n                   (announce-output \&quot;;;; there are no more values of \&quot;)\n                   (user-print input)\n                   (driver-loop)))))))\n(defn driver-loop []\n  (driver-loop-inner\n    (fn []\n      (println \&quot;;;; no current problem\&quot;)\n      (driver-loop))))&quot;, :offset 5988, :ns &quot;user&quot;} {:command &quot;(get-args (analyze 1)\n          {}\n          (fn [a b] (println a))\n          (fn [] (println 'e)))&quot;, :offset 99, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(get-args (list (analyze 1))\n          {}\n          (fn [a b] (println a))\n          (fn [] (println 'e)))&quot;, :offset 106, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(def a (analyze 1))&quot;, :offset 19, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(get-args (list (analyze 1))\n          {}\n          (fn [a b] (println \&quot;fucking success \&quot; a))\n          (fn [] (println \&quot;fucking error\&quot;)))&quot;, :offset 138, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(get-args (list (analyze 1))\n          {}\n          (fn [a b] )\n          (fn [] ))&quot;, :offset 83, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(get-args (list (analyze 1) (analyze 2))\n          {}\n          (fn [a b] (println \&quot;fucking success \&quot; a))\n          (fn [] (println \&quot;fucking error\&quot;)))&quot;, :offset 150, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    (primitive-procedure-name? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (primitive-procedure-map exp) env)\n        fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))&quot;, :offset 463, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(analyze 1)&quot;, :offset 11, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(a {}\n   (fn [a b] (println a))\n   (fn [] (println 'e)))&quot;, :offset 56, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(#'the-global-env)&quot;, :offset 18, :ns &quot;interpreter.impl.default&quot;} {:command &quot;#'the-global-env&quot;, :offset 16, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(def ^:private the-global-env (atom {1 1}))&quot;, :offset 43, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env (fn [old-env] (merge old-env {2 2})))&quot;, :offset 59, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env (fn [old-env] (merge old-env {2 3})))&quot;, :offset 59, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env (fn [old-env] (merge old-env {2 3})))\n\n(deref the-global-env)&quot;, :offset 83, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env (fn [old-env] (merge old-env {1 2})))&quot;, :offset 59, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(deref the-global-env)&quot;, :offset 22, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env #(merge % {1 2}))&quot;, :offset 39, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env #(merge % {2 3}))&quot;, :offset 39, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(def ^:private the-global-env (atom {}))&quot;, :offset 40, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(swap! the-global-env #(assoc % 1 2))&quot;, :offset 37, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(defn- define-variable! [var val env-atom]\n  (swap! env-atom #(assoc % var val)))&quot;, :offset 81, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(def l PersistentList)&quot;, :offset 22, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(ns interpreter.default-test\n  (:refer-clojure :exclude [eval true?])\n  (:require [clojure.test :refer :all]\n            [interpreter.type :refer :all]\n            [interpreter.impl.default :refer :all]))\n\n(defmacro expect\n  [a b]\n  `(is (= ~a ~b)))\n\n(def eval #'interpreter.impl.default/eval)                  ; test private\n\n(deftest primitive-eval\n  (testing\n    [(expect '3 (eval '3))\n     (expect 'TRUE (eval 'TRUE))\n     (expect 2 (eval '(+ 1 1)))\n     (expect 5 (eval '(+ (+ 1 2) 1 1)))\n     (expect 3 (eval-program '[3]))]))\n\n(deftest env-eval\n  (testing\n    [(expect 2 (eval 'a {'a 2}))\n\n     (expect 3\n             (eval-program\n               '[(def a 3)\n                 a]))\n\n     ; test state inside do\n     (expect 4\n             (eval-program\n               '[(do (def x 2)\n                     (+ x x))]))\n\n     (expect {'a 3}\n             (:env (#'interpreter.impl.default/eval-sexp '(def a 3) {})))]))\n\n(deftest seq-eval\n  (testing\n    [(expect '2\n             (eval '(if TRUE 2 3)))\n\n     (expect '3\n             (eval '(if FALSE 2 3)))\n\n     (expect '(if test\n                result)\n             (cond-&gt;if '(cond test result)))\n\n     (expect '(if c1\n                r1\n                (if c2\n                  r2))\n             (cond-&gt;if '(cond c1 r1\n                              c2 r2)))\n\n     (expect 3\n             (eval '(if TRUE 3)))\n\n     (expect '(if TRUE 3)\n             (cond-&gt;if '(cond TRUE\n                              3)))\n\n     (expect 3\n             (eval '(cond TRUE 3)))\n\n     (expect 2\n             (eval '((fn [x] x) 2)))\n\n     (expect 4\n             (eval-program '[(def f (fn [y] y))\n                             (f 4)]))\n\n     (expect 25\n             (eval-program '[(def square (fn [x] (* x x)))\n                             (+ (square 3) (square 4))]))\n\n     (expect 1\n             (eval-program '[(if TRUE 1 2)]))\n\n     (expect 2\n             (eval-program '[(if FALSE 1 2)]))\n\n     (expect 'NIL\n             (eval '(if FALSE 1)))\n\n     (expect 1\n             (eval-program '[(def a 1)\n                             (if TRUE 1)\n                             a]))\n\n     (expect 8\n             (eval-program '[(def add-n (fn [n]\n                                          (fn [r]\n                                            (+ n r))))\n                             ((add-n 3) 5)]))\n\n     (expect '((fn [a c]\n                 (+ a c))\n                b d)\n             (let-&gt;fn '(let [a b\n                             c d]\n                         (+ a c))))\n\n     (expect 3\n             (eval '(let [a 3]\n                      a)))\n\n     (expect 5\n             (eval '(let [f (fn [x] (+ x 2))]\n                      (f 3))))]))\n\n(deftest scheme-syntax\n  (let [preamble '[(def cons (fn [x y]\n                               (fn [m]\n                                 (cond (= m 0) x\n                                       (= m 1) y))))\n                   (def car (fn [z] (z 0)))\n                   (def cdr (fn [z] (z 1)))\n                   (def t (cons 3 4))]]\n    (testing\n      [(expect 'TRUE\n               (eval-program (concat preamble\n                                     '[(= (car t) 3)])))\n\n       (expect 'TRUE\n               (eval-program (concat preamble\n                                     '[(= (cdr t) 4)])))\n\n       (expect 7\n               (eval '(((fn [x]\n                          (fn [y] (+ x y)))\n                         3)\n                        4)))])))\n\n(deftest factorial-eval\n  (testing\n    [\n     (expect 1\n             (eval-program '[(defn factorial [n]\n                               (if (= n 1)\n                                 1\n                                 (* n (factorial (- n 1)))))\n                             (factorial 1)]))\n\n     (expect 6\n             (eval-program '[(defn factorial [n]\n                               (if (= n 1)\n                                 1\n                                 (* n (factorial (- n 1)))))\n                             (factorial 3)]))\n     ]))&quot;, :offset 3968, :ns &quot;user&quot;} {:command &quot;(primitive-eval)&quot;, :offset 16, :ns &quot;interpreter.default-test&quot;} {:command &quot;(ns interpreter.impl.nondeterministic\n  (:refer-clojure :exclude [eval true?]\n                  :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import (interpreter.type State Proc)\n           (clojure.lang PersistentList)))&quot;, :offset 250, :ns &quot;user&quot;} {:command &quot;(print l)&quot;, :offset 9, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(def ^{:deprecated} l PersistentList)&quot;, :offset 37, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(declare analyze)\n\n(defn- execute-application\n  \&quot;proc is \&quot;\n  [proc args succeed fail]\n  (println \&quot;inside execute-application\&quot;)\n  (cond\n    (primitive-procedure? proc)\n    (do\n      (println \&quot;it's a primitive proc \&quot; proc)\n      (succeed (clj-apply proc\n                          args)\n               fail))\n\n    (compound-procedure? proc)\n    (do\n      (println \&quot;it's a compount proc \&quot; + proc)\n      ((:body proc)\n        (merge\n          (:env proc)\n          {(:name proc) proc}\n          (zipmap (:params proc)\n                  args))\n        succeed\n        fail))\n\n    :else\n    (error \&quot;EXECUTE-APPLICATION FAIL: \&quot; proc args)))\n\n;(execute-application '+ '(1 1) #(println %1 %2) #(println 'fail))\n\n(defmulti analyze-seq (fn [exp] (first exp)))\n\n(defn- amb-choices [exp] (rest exp))\n\n(defn amb-try-next [choices env succeed fail]\n  (if (empty? choices)\n    (fail)\n    ((first choices)\n      env\n      succeed\n      (fn [] (amb-try-next (rest choices) env succeed fail)))))\n\n(defmethod analyze-seq 'amb\n  [exp]\n  (let [cprocs (map analyze (amb-choices exp))]\n    (println cprocs)\n    (fn [env succeed fail]\n      (amb-try-next cprocs env succeed fail))))\n\n(defn- sequentially [a b stop? init]\n  (fn [env succeed fail]\n    (a env\n       (fn [a-value fail2]\n         (if (stop? a-value)\n           (b env succeed fail2)\n           (succeed (State. (not init) env)\n                    fail2)))\n       fail)))\n(defn- analyze-logic [exps stop? init]\n  (loop [first-proc (fn [env succeed fail] (succeed (State. init env) fail))\n         rest-procs (map analyze exps)]\n    (if (empty? rest-procs)\n      first-proc\n      (recur (sequentially first-proc (first rest-procs) stop? init)\n             (rest rest-procs)))))\n(defmethod analyze-seq 'and\n  [[_ exps]]\n  (analyze-logic exps identity true))\n(defmethod analyze-seq 'or\n  [[_ exps]]\n  (analyze-logic exps not false))\n\n(defn- get-args [aprocs env succeed fail]\n  (if (empty? aprocs)\n    (succeed (State. '() env) fail)\n    ((first aprocs)\n      env\n      ;; succeed for this aproc\n      (fn [arg fail2]\n        (get-args (rest aprocs)\n                  env\n                  ;; succeed for get-args\n                  (fn [args fail3]\n                    (succeed (State. (cons arg args) env)\n                             fail3))\n                  fail2))\n      fail)))\n(defmethod analyze-seq :default\n  [[op &amp; operands]]\n  ;; example (+ 1 2)\n  (let [fproc     (analyze op) ; State{+ env}\n        arg-procs (map analyze operands)] ;'(State{1 env} State{2 env})\n    (fn [env succeed fail]\n      (fproc env\n             ;; succeed\n             (fn [proc fail2]\n               (get-args arg-procs\n                         env\n                         (fn [args fail3]\n                           (println \&quot;about to invoke ex ap, proc \&quot; proc)\n                           (execute-application\n                             proc args succeed fail3))\n                         fail2))\n             fail))))\n\n;; todo: rm\n;(defmethod analyze-seq :default\n;  [[op &amp; operands]]\n;  (let [evaled-op (eval op env)]\n;    (println \&quot;evOp is \&quot; evaled-op)\n;    (State. (apply evaled-op\n;                   (map (fn [operand]\n;                          (eval operand env))\n;                        operands))\n;            env)))\n;\n;;; todo: remove\n;;(def a (analyze '(+ 1 1)))\n;(def a (analyze 1))\n\n(get-args (list (analyze 1) (analyze 2))\n          {}\n          (fn [a b] (println \&quot;fucking success \&quot; a))\n          (fn [] (println \&quot;fucking error\&quot;)))\n\n(a {}\n   (fn [a b] (println a))\n   (fn [] (println 'e)))\n\n(defmethod analyze-seq 'def\n  [[_ name val]]\n  (let [vproc (analyze val)]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'defn\n  [[_ name params &amp; body]]\n  (let [vproc (analyze (make-fn params body))]\n    (fn [env succeed fail]\n      (vproc env\n             (fn [val fail2]\n               (succeed (State. 'NIL (assoc env name val))\n                        fail2))\n             fail))))\n\n(defmethod analyze-seq 'fn\n  [_ vars body] ; body\n  (let [bproc (analyze-seq body)]\n    (fn [env succeed fail]\n      (succeed\n        (State.\n          (Proc. vars bproc env nil)\n          env)\n        fail))))\n\n(defn analyze [exp]\n  (cond\n    (number? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. exp env)\n        fail))\n\n    (symbol? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (env exp) env)\n        fail))\n\n    (primitive-procedure-name? exp)\n    (fn [env succeed fail]\n      (succeed\n        (State. (primitive-procedure-map exp) env)\n        fail))\n\n    (seq? exp)\n    (analyze-seq exp)\n\n    :else\n    (error \&quot;ANALYZE FAIL: \&quot; exp)))\n\n(defn ambeval\n  \&quot;succeed is like  (fn [val fail] ...)\n   fail    is like  (fn [] ... )\&quot;\n  [exp env succeed fail]\n  ((analyze exp) env succeed fail))\n\n\n(def ^:private input-prompt \&quot;;;; Input Amb-Eval:\&quot;)\n(def ^:private output-prompt \&quot;;;; Values Amb-Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n\n(defn- announce-output [str]\n  (println str))\n(defn- user-print [object]\n  (println output-prompt object))\n\n(def global-state-atom (atom initial-state))\n\n(declare driver-loop)\n(defn- driver-loop-inner [try-again]\n  (prompt-for-input input-prompt)\n  (let [input (read-string (read-line))]\n    (if (= input 'try-again)\n      (try-again)\n      (do\n        (println \&quot;;;; starting a new problem\&quot;)\n        (ambeval input ; do we need to wrap it in list?\n                 (:env #'global-state-atom)\n                 ;; success continuation\n                 (fn [output-state next-alternative]\n                   (announce-output output-prompt)\n                   (user-print (:result output-state))\n                   (swap! global-state-atom (fn [_] output-state))\n                   (driver-loop-inner next-alternative))\n                 ;; failure continuation\n                 (fn []\n                   (announce-output \&quot;;;; there are no more values of \&quot;)\n                   (user-print input)\n                   (driver-loop)))))))\n(defn driver-loop []\n  (driver-loop-inner\n    (fn []\n      (println \&quot;;;; no current problem\&quot;)\n      (driver-loop))))&quot;, :offset 6208, :ns &quot;interpreter.impl.nondeterministic&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?] :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import [interpreter.type Proc State]))&quot;, :offset 182, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?] :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import [interpreter.type Proc State]))\n\n(declare apply eval)\n\n;; todo: move in common place?\n(def ^:private the-global-env (atom {}))\n\n(defn- define-variable!\n  ([name val]\n   (define-variable! the-global-env name val))\n  ([env-atom name val]\n   (swap! env-atom #(assoc % name val))))\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'ok\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (apply evaled-op\n           (map (fn [operand]\n                  (eval operand env))\n                operands))))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (let [[name exp] operands\n        value (eval exp env)]\n    (define-variable! name value))\n  'ok)\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (let [[name params body] operands\n        new-fn (Proc. params body env name)]\n    (define-variable! name new-fn))\n  'ok)\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (eval-if sexp env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (Proc. params\n           body\n           env\n           nil)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    sexp\n\n    (primitive-procedure-name? sexp)\n    (primitive-procedure-map sexp)\n\n    (symbol? sexp)\n    (env sexp)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n(defn- eval\n  ([sexp] (eval sexp the-global-env))\n  ([sexp env]\n   (eval-sexp sexp env)))\n\n(defn- next-state [last-state sexp]\n  {:deprecated \&quot;now\&quot;}\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  {:deprecated \&quot;now\&quot;}\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n(def ^:private input-prompt \&quot;;;; Input Eval\&quot;)\n(def ^:private output-prompt \&quot;;;; Value Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n(def ^:private announce-output #(println %))\n\n(defn- user-print [input output]\n  (println \&quot;\&quot;)\n  (println output-prompt object))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))\n\n\n;(let [input (read-string (read-line))\n;      output (eval input the-global-env)]\n;  (println output))\n\n(defn print-loop []\n  (loop [env the-global-env]\n    (prompt-for-input input-prompt)\n    (let [input (read-string (read-line))\n          output (eval input env)]\n      (user-print input output)\n      (recur env))))&quot;, :offset 3904, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?] :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import [interpreter.type Proc State]))\n\n(declare apply eval)\n\n;; todo: move in common place?\n(def ^:private the-global-env (atom {}))\n\n(defn- define-variable!\n  ([name val]\n   (define-variable! the-global-env name val))\n  ([env-atom name val]\n   (swap! env-atom #(assoc % name val))))\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'ok\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (apply evaled-op\n           (map (fn [operand]\n                  (eval operand env))\n                operands))))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (let [[name exp] operands\n        value (eval exp env)]\n    (define-variable! name value))\n  'ok)\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (let [[name params body] operands\n        new-fn (Proc. params body env name)]\n    (define-variable! name new-fn))\n  'ok)\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (eval-if sexp env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (Proc. params\n           body\n           env\n           nil)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    sexp\n\n    (primitive-procedure-name? sexp)\n    (primitive-procedure-map sexp)\n\n    (symbol? sexp)\n    (env sexp)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n(defn- eval\n  ([sexp] (eval sexp the-global-env))\n  ([sexp env]\n   (eval-sexp sexp env)))\n\n(defn- next-state [last-state sexp]\n  {:deprecated \&quot;now\&quot;}\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  {:deprecated \&quot;now\&quot;}\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n(def ^:private input-prompt \&quot;;;; Input Eval\&quot;)\n(def ^:private output-prompt \&quot;;;; Value Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n(def ^:private announce-output #(println %))\n\n(defn- user-print [input output]\n  (println \&quot;\&quot;)\n  (println output-prompt))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))\n\n\n;(let [input (read-string (read-line))\n;      output (eval input the-global-env)]\n;  (println output))\n\n(defn print-loop []\n  (loop [env the-global-env]\n    (prompt-for-input input-prompt)\n    (let [input (read-string (read-line))\n          output (eval input env)]\n      (user-print input output)\n      (recur env))))&quot;, :offset 3897, :ns &quot;user&quot;} {:command &quot;(ns interpreter.default-test\n  (:refer-clojure :exclude [eval true?])\n  (:require [clojure.test :refer :all]\n            [interpreter.type :refer :all]\n            [interpreter.impl.default :refer :all]))&quot;, :offset 204, :ns &quot;user&quot;} {:command &quot;(println the-global-env)&quot;, :offset 24, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(ns interpreter.core\n  (:require [interpreter.impl.default :as default])\n  (:gen-class))&quot;, :offset 88, :ns &quot;user&quot;} {:command &quot;(ns interpreter.impl.default\n  (:refer-clojure :exclude [eval true?] :rename {apply clj-apply})\n  (:require [interpreter.type :refer :all])\n  (:import [interpreter.type Proc State]))\n\n(declare apply eval)\n\n;; todo: move in common place?\n(def ^:private the-global-env (atom {}))\n\n(println the-global-env)\n\n(defn- define-variable!\n  ([name val]\n   (define-variable! the-global-env name val))\n  ([env-atom name val]\n   (swap! env-atom #(assoc % name val))))\n\n(defn eval-if [[_ pred consequent alternative] env]\n  (if (true? (eval pred env))\n    (eval consequent env)\n    (if (nil? alternative)\n      'ok\n      (eval alternative env))))\n\n(defn let-&gt;fn [[_ bindings body]]\n  (let [params (take-nth 2 bindings)\n        args   (take-nth 2 (rest bindings))]\n    (cons\n      (make-fn params body)\n      args)))\n\n(defn eval-let [[bindings body] env]\n  (eval body (merge env\n                    (map-vals #(eval % env) (clj-apply hash-map bindings)))))\n\n(defmulti eval-seq (fn [sexp env] (first sexp)))\n\n(defmethod eval-seq :default\n  [[op &amp; operands] env]\n  (let [evaled-op (eval op env)]\n    (apply evaled-op\n           (map (fn [operand]\n                  (eval operand env))\n                operands))))\n\n(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (let [[name exp] operands\n        value (eval exp env)]\n    (define-variable! name value))\n  'ok)\n\n(defmethod eval-seq 'defn\n  [[_ &amp; operands] env]\n  (let [[name params body] operands\n        new-fn (Proc. params body env name)]\n    (define-variable! name new-fn))\n  'ok)\n\n(defmethod eval-seq 'if\n  [sexp env]\n  (eval-if sexp env))\n\n(defmethod eval-seq 'cond\n  [sexp env]\n  (eval-seq (cond-&gt;if sexp) env))\n\n(defmethod eval-seq 'let\n  [sexp env]\n  (eval-seq (let-&gt;fn sexp) env))\n\n(defmethod eval-seq 'fn\n  [[op &amp; operands] env]\n  (let [[params body] operands]\n    (Proc. params\n           body\n           env\n           nil)))\n\n(defn- eval-sexp [sexp env]\n  (cond\n    (self-evaluating? sexp)\n    sexp\n\n    (primitive-procedure-name? sexp)\n    (primitive-procedure-map sexp)\n\n    (symbol? sexp)\n    (env sexp)\n\n    (seq? sexp)\n    (eval-seq sexp env)\n\n    :else\n    (error \&quot;EVAL FAIL: \&quot; sexp)))\n\n(defn- apply [proc args]\n  (cond\n    (primitive-procedure? proc)\n    (clj-apply proc args)\n\n    (compound-procedure? proc)\n    (eval (:body proc)\n          (merge\n            (:env proc)\n            {(:name proc) proc}\n            (zipmap (:params proc)\n                    args)))\n\n    :else\n    (error \&quot;APPLY FAIL: \&quot; proc args)))\n\n(defn- eval\n  ([sexp] (eval sexp the-global-env))\n  ([sexp env]\n   (eval-sexp sexp env)))\n\n(defn- next-state [last-state sexp]\n  {:deprecated \&quot;now\&quot;}\n  (let [env (:env last-state)]\n    (eval-sexp sexp env)))\n\n(defn reduce-state [initial-state sexps]\n  {:deprecated \&quot;now\&quot;}\n  (reduce next-state initial-state sexps))\n\n(defmethod eval-seq 'do\n  [[_ &amp; operands] env]\n  (reduce-state (State. 'NIL env) operands))\n\n(defn eval-program [sexps]\n  (:result (reduce-state initial-state sexps)))\n\n;; driver\n(def ^:private input-prompt \&quot;;;; Input Eval\&quot;)\n(def ^:private output-prompt \&quot;;;; Value Eval:\&quot;)\n(def ^:private prompt-for-input #(println %))\n(def ^:private announce-output #(println %))\n\n(defn- user-print [input output]\n  (println \&quot;\&quot;)\n  (println output-prompt))\n\n(defn print-loop\n  \&quot;reduce-state-fn should be fn, that take State and sexps\n  and return State as a result of evaluating sexps\&quot;\n  [reduce-state-fn]\n  (loop [state initial-state]\n    (prompt-for-input input-prompt)\n    (let [input  (read-string (read-line))\n          output (reduce-state-fn state (list input))]\n      (user-print (:result output))\n      (recur output))))\n\n\n;(let [input (read-string (read-line))\n;      output (eval input the-global-env)]\n;  (println output))\n\n(defn print-loop []\n  (loop [env the-global-env]\n    (prompt-for-input input-prompt)\n    (let [input (read-string (read-line))\n          output (eval input env)]\n      (user-print input output)\n      (recur env))))&quot;, :offset 3923, :ns &quot;user&quot;} {:command &quot;(eval '(+ 1 1))&quot;, :offset 15, :ns &quot;interpreter.impl.default&quot;} {:command &quot;(defmethod eval-seq 'def\n  [[_ &amp; operands] env]\n  (let [[name exp] operands\n        value (eval exp env)]\n    (define-variable! name value))\n  'ok)&quot;, :offset 147, :ns &quot;interpreter.impl.default&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Clj">
    <configuration name="Clj" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="interpreter" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="interpreter.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="interpreter" />
      <setting name="path" value="" />
      <setting name="namespace" value="interpreter.core" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="default" />
      <setting name="workDir" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <configuration name="interpreter.raw" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="interpreter" />
      <setting name="path" value="" />
      <setting name="namespace" value="interpreter.raw" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <configuration name="interpreter.raw2" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="interpreter" />
      <setting name="path" value="" />
      <setting name="namespace" value="interpreter.raw2" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure Application.interpreter.core" />
      <item itemvalue="Clojure Application.interpreter.raw" />
      <item itemvalue="Clojure Application.interpreter.raw2" />
      <item itemvalue="Clojure REPL.Clj" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure Application.interpreter.core" />
        <item itemvalue="Clojure Application.interpreter.raw2" />
        <item itemvalue="Clojure Application.interpreter.raw" />
      </list>
    </recent_temporary>
  </component>
  <component name="TodoView" selected-index="1">
    <todo-panel id="selected-file">
      <is-autoscroll-to-source value="true" />
    </todo-panel>
    <todo-panel id="all">
      <are-packages-shown value="true" />
      <is-autoscroll-to-source value="true" />
    </todo-panel>
  </component>
  <component name="ToolWindowManager">
    <frame x="0" y="23" width="1440" height="877" extended-state="0" />
    <layout>
      <window_info content_ui="combo" id="Project" order="0" weight="0.29027778" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info id="Image Layers" order="2" />
      <window_info id="Designer" order="3" />
      <window_info id="UI Designer" order="4" />
      <window_info id="Capture Tool" order="5" />
      <window_info id="Favorites" order="6" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info anchor="bottom" id="Run" order="2" weight="0.39766082" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.4" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.32982457" />
      <window_info anchor="bottom" id="Terminal" order="7" weight="0.32865497" />
      <window_info anchor="bottom" id="Event Log" order="8" side_tool="true" />
      <window_info anchor="bottom" id="Version Control" order="9" weight="0.32982457" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" id="Ant Build" order="1" weight="0.25" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="2" weight="0.25" />
      <window_info anchor="right" id="Palette" order="3" />
      <window_info anchor="right" id="Maven" order="4" sideWeight="0.4985591" weight="0.32936507" />
      <window_info anchor="right" id="Theme Preview" order="5" />
      <window_info anchor="right" x="0" y="435" width="864" height="487" id="REPL" order="6" sideWeight="0.50432277" side_tool="true" weight="0.31527779" />
      <window_info anchor="right" id="Leiningen" order="7" sideWeight="0.49567723" weight="0.32936507" />
      <window_info anchor="right" id="Capture Analysis" order="8" />
      <window_info anchor="right" id="Palette&#9;" order="9" />
      <window_info anchor="right" id="Key Promoter X" order="10" />
    </layout>
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="ad" />
    <MESSAGE value="add 'do', add more primitive functions; refactor some code" />
    <option name="LAST_COMMIT_MESSAGE" value="add 'do', add more primitive functions; refactor some code" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/interpreter/impl/default.clj</url>
          <line>99</line>
          <properties />
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
    </breakpoint-manager>
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/src/interpreter/raw.kt" />
    <entry file="file://$PROJECT_DIR$/src/interpreter/raw.clj" />
    <entry file="jar:///Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home/jre/lib/rt.jar!/com/sun/xml/internal/bind/v2/TODO.class">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="60">
          <caret line="7" column="22" selection-start-line="7" selection-start-column="22" selection-end-line="7" selection-end-column="22" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/interpreter/core_test.clj" />
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/lang/Namespace.class">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="456">
          <caret line="99" column="38" lean-forward="true" selection-start-line="99" selection-start-column="38" selection-end-line="99" selection-end-column="38" />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="345">
          <caret line="552" column="10" selection-start-line="552" selection-start-column="10" selection-end-line="552" selection-end-column="10" />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/lang/Compiler.class">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="465">
          <caret line="507" column="59" selection-start-line="507" selection-start-column="59" selection-end-line="507" selection-end-column="59" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/interpreter/driver.clj" />
    <entry file="file://$PROJECT_DIR$/src/interpreter/type.clj">
      <provider selected="true" editor-type-id="text-editor" />
    </entry>
    <entry file="file://$PROJECT_DIR$/test/interpreter/.#default_test.clj" />
    <entry file="file://$PROJECT_DIR$/src/interpreter/impl/nondeterministic.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="585">
          <caret line="39" selection-start-line="39" selection-end-line="39" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="13" selection-start-line="13" selection-end-line="13" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/interpreter/default_test.clj">
      <provider selected="true" editor-type-id="text-editor" />
    </entry>
    <entry file="file://$PROJECT_DIR$/src/interpreter/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="135">
          <caret line="9" column="10" selection-start-line="9" selection-start-column="10" selection-end-line="9" selection-end-column="10" />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="291">
          <caret line="189" column="1" selection-start-line="189" selection-start-column="1" selection-end-line="189" selection-end-column="1" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/interpreter/impl/default.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="150">
          <caret line="10" column="9" selection-start-line="10" selection-start-column="9" selection-end-line="10" selection-end-column="9" />
        </state>
      </provider>
    </entry>
  </component>
</project>